# This script is generated by the chatGPT from "handler.js" file
## NOT TESTED YET!!
import boto3
import json

# Initialize boto3 clients for Step Functions and DynamoDB
step_functions_client = boto3.client('stepfunctions', region_name='us-east-1')
dynamodb_client = boto3.client('dynamodb', region_name='us-east-1')
document_client = boto3.resource('dynamodb', region_name='us-east-1')

def is_book_available(book, quantity):
    return (book['quantity'] - quantity) > 0

def check_inventory(book_id, quantity):
    try:
        table = document_client.Table('bookTable')
        response = table.query(KeyConditionExpression=boto3.dynamodb.conditions.Key('bookId').eq(book_id))
        print(response)
        book = response['Items'][0]

        if is_book_available(book, quantity): return book
        else: raise Exception("The book is out of stock")
    
    except Exception as e:
        if str(e) == 'The book is out of stock': raise e
        else: raise Exception('BookNotFound: ' + str(e))

def calculate_total(book, quantity):
    print("book: ", book)
    total = book['price'] * quantity
    return {'total': total}

def bill_customer(params):
    print(params)
    # throw 'Error in billing'
    # Bill the customer e.g. Using Stripe token from the parameters
    return "Successfully Billed"

def deduct_points(user_id):
    table = document_client.Table('userTable')
    table.update_item(
        Key={'userId': user_id},
        UpdateExpression='set points = :zero',
        ExpressionAttributeValues={
            ':zero': 0
        }
    )

def update_book_quantity(book_id, order_quantity):
    print("bookId: ", book_id)
    print("orderQuantity: ", order_quantity)
    table = document_client.Table('bookTable')
    table.update_item(
        Key={'bookId': book_id},
        UpdateExpression='SET quantity = quantity - :orderQuantity',
        ExpressionAttributeValues={
            ':orderQuantity': order_quantity
        }
    )

def redeem_points(user_id, total):
    print("userId: ", user_id)
    order_total = total['total']
    print("orderTotal:", order_total)
    try:
        table = document_client.Table('userTable')
        response = table.get_item(
            Key={'userId': user_id}
        )
        user = response['Item']
        print("user: ", user)
        points = user['points']
        print("points: ", points)
        if order_total > points:
            deduct_points(user_id)
            order_total = order_total - points
            return {'total': order_total, 'points': points}
        else:
            raise Exception('Order total is less than redeem points')
    except Exception as e:
        raise Exception('RedeemPointsError: ' + str(e))

def restore_redeem_points(user_id, total):
    try:
        if 'points' in total:
            table = document_client.Table('userTable')
            table.update_item(
                Key={'userId': user_id},
                UpdateExpression='set points = :points',
                ExpressionAttributeValues={
                    ':points': total['points']
                }
            )
    except Exception as e:
        raise Exception('RestoreRedeemPointsError: ' + str(e))

def sqs_worker(event):
    try:
        print(json.dumps(event))
        record = event['Records'][0]
        body = json.loads(record['body'])
        # Find a courier and attach courier information to the order
        courier = "<courier email>"

        # update book quantity
        update_book_quantity(body['Input']['bookId'], body['Input']['quantity'])

        # throw "Something wrong with Courier API"

        # Attach courier information to the order
        step_functions_client.send_task_success(
            output=json.dumps({'courier': courier}),
            taskToken=body['Token']
        )
    except Exception as e:
        print("===== You got an Error =====")
        print(e)
        step_functions_client.send_task_failure(
            error="NoCourierAvailable",
            cause="No couriers are available",
            taskToken=body['Token']
        )

def restore_quantity(book_id, quantity):
    table = document_client.Table('bookTable')
    table.update_item(
        Key={'bookId': book_id},
        UpdateExpression='set quantity = quantity + :orderQuantity',
        ExpressionAttributeValues={
            ':orderQuantity': quantity
        }
    )
    return "Quantity restored"
