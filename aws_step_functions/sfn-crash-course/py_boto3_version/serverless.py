# This script is generated by the chatGPT from "serverless.yml" file
## NOT TESTED YET!!
#==============================================================================

import boto3
import json
import os

from dynamodb import create_dynamodbs
## ============================================================================

# Initialize boto3 clients
iam_client = boto3.client('iam')
lambda_client = boto3.client('lambda')
stepfunctions_client = boto3.client('stepfunctions')
dynamodb_client = boto3.client('dynamodb')
sqs_client = boto3.client('sqs')
sns_client = boto3.client('sns')

account_id = os.environ['AWS_ACCOUNT_ID_ROOT']
region = os.environ['AWS_DEFAULT_REGION']

# 1. Create IAM Roles and Policies
def create_iam_role(role_name, policy_document, description=""):
    try:
        response = iam_client.create_role(
            RoleName=role_name,
            AssumeRolePolicyDocument=json.dumps(policy_document),
            Description=description
        )
        return response['Role']['Arn']
    except iam_client.exceptions.EntityAlreadyExistsException:
        print(f"Role {role_name} already exists.")
        return iam_client.get_role(RoleName=role_name)['Role']['Arn']

def attach_role_policy(role_name, policy_arn):
    iam_client.attach_role_policy(
        RoleName=role_name,
        PolicyArn=policy_arn
    )

lambda_trust_policy = {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Service": "lambda.amazonaws.com"
            },
            "Action": "sts:AssumeRole"
        }
    ]
}

stepfunctions_trust_policy = {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Service": "states.amazonaws.com"
            },
            "Action": "sts:AssumeRole"
        }
    ]
}

lambda_role_arn = create_iam_role("LambdaExecutionRole", lambda_trust_policy, "Role for Lambda execution")
stepfunctions_role_arn = create_iam_role("StepFunctionsExecutionRole", stepfunctions_trust_policy, "Role for Step Functions execution")

lambda_policy_arn = 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
# dynamodb_policy_arn = f'arn:aws:dynamodb:{region}:{account_id}:table/*'
# sns_policy_arn = f'arn:aws:sns:{region}:{account_id}:NotifyCourier'
# sqs_policy_arn = f'arn:aws:sqs:{region}:{account_id}:OrdersQueue'
# states_policy_arn = f'arn:aws:states:{region}:{account_id}:stateMachine:storeCheckoutFlow'
dynamodb_policy_arn = "arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess"
sns_policy_arn = "arn:aws:iam::aws:policy/AmazonSNSFullAccess"
sqs_policy_arn = "arn:aws:iam::aws:policy/AmazonSQSFullAccess"
states_policy_arn = "arn:aws:iam::aws:policy/AWSStepFunctionsFullAccess"


attach_role_policy("LambdaExecutionRole", lambda_policy_arn)
attach_role_policy("LambdaExecutionRole", dynamodb_policy_arn)
attach_role_policy("LambdaExecutionRole", sns_policy_arn)
attach_role_policy("LambdaExecutionRole", sqs_policy_arn)

# 2. Create Lambda functions
def create_or_update_lambda_function(func_name, handler, role_arn, zip_file):
    try:
        # Check if function already exists
        lambda_client.get_function(FunctionName=func_name)
        # If function exists, update its code
        response = lambda_client.update_function_code(
            FunctionName=func_name,
            ZipFile=open(zip_file, 'rb').read(),
        )
        print(f"Updated Lambda function {func_name}.")
        return response['FunctionArn']
    except lambda_client.exceptions.ResourceNotFoundException:
        # If function does not exist, create it
        response = lambda_client.create_function(
            FunctionName=func_name,
            Runtime='python3.9',
            Role=role_arn,
            Handler=handler,
            Code={'ZipFile': open(zip_file, 'rb').read()},
            Timeout=300,
        )
        print(f"Created Lambda function {func_name}.")
        return response['FunctionArn']
    except Exception as e:
        print(f"Error creating or updating Lambda function {func_name}: {e}")

# Replace with the actual path to your Lambda deployment packages
lambda_functions = {
    'checkInventory': 'handlers.check_inventory',
    'calculateTotal': 'handlers.calculate_total',
    'redeemPoints': 'handlers.redeem_points',
    'billCustomer': 'handlers.bill_customer',
    'restoreRedeemPoints': 'handlers.restore_redeem_points',
    'restoreQuantity': 'handlers.restore_quantity',
    'sqsWorker': 'handlers.sqs_worker'
}

lambda_arns = {}

for func, handler in lambda_functions.items():
    lambda_arns[func] = create_or_update_lambda_function(func, handler, lambda_role_arn, 'handlers.zip')
    print(lambda_arns[func])

# 3. Create Step Functions state machine
state_machine_definition = {
    "Comment": "Store Checkout Flow",
    "StartAt": "checkInventory",
    "States": {
        "checkInventory": {
            "Type": "Task",
            "Resource": lambda_arns['checkInventory'],
            "Catch": [
                {
                    "ErrorEquals": ["BookNotFound"],
                    "Next": "BookNotFoundError"
                },
                {
                    "ErrorEquals": ["BookOutOfStock"],
                    "Next": "BookOutOfStockError"
                }
            ],
            "ResultPath": "$.book",
            "Next": "calculateTotal"
        },
        "calculateTotal": {
            "Type": "Task",
            "Resource": lambda_arns['calculateTotal'],
            "ResultPath": "$.total",
            "Next": "isRedeemNeeded"
        },
        "isRedeemNeeded": {
            "Type": "Choice",
            "Choices": [
                {
                    "Variable": "$.redeem",
                    "BooleanEquals": True,
                    "Next": "RedeemPoints"
                }
            ],
            "Default": "BillCustomer"
        },
        "RedeemPoints": {
            "Type": "Task",
            "Resource": lambda_arns['redeemPoints'],
            "ResultPath": "$.total",
            "Catch": [
                {
                    "ErrorEquals": ["States.ALL"],
                    "Next": "RedeemPointsError"
                }
            ],
            "Next": "BillCustomer"
        },
        "BillCustomer": {
            "Type": "Task",
            "Resource": lambda_arns['billCustomer'],
            "ResultPath": "$.billingStatus",
            "Retry": [
                {
                    "ErrorEquals": ["States.ALL"],
                    "MaxAttempts": 0
                }
            ],
            "Catch": [
                {
                    "ErrorEquals": ["States.ALL"],
                    "ResultPath": "$.customerBilling",
                    "Next": "BillingError"
                }
            ],
            "Next": "PrepareOrder"
        },
        "PrepareOrder": {
            "Type": "Task",
            "Resource": "arn:aws:states:::sqs:sendMessage.waitForTaskToken",
            "Parameters": {
                "QueueUrl": f"https://sqs.{region}.amazonaws.com/{account_id}/OrdersQueue",
                "MessageBody": {
                    "Input.$": "$",
                    "Token.$": "$$.Task.Token"
                }
            },
            "ResultPath": "$.courierStatus",
            "Catch": [
                {
                    "ErrorEquals": ["NoCourierAvailable"],
                    "ResultPath": "$.courierError",
                    "Next": "RefundCustomer"
                }
            ],
            "Next": "DispatchOrder"
        },
        "DispatchOrder": {
            "Type": "Task",
            "Resource": "arn:aws:states:::sns:publish",
            "Parameters": {
                "TopicArn": f"arn:aws:sns:{region}:{account_id}:NotifyCourier",
                "Message.$": "$"
            },
            "Next": "Dispatched"
        },
        "Dispatched": {
            "Type": "Pass",
            "Result": "Your order will be dispatched in 24 hours",
            "End": True
        },
        "RestoreRedeemPoints": {
            "Type": "Task",
            "Resource": lambda_arns['restoreRedeemPoints'],
            "End": True
        },
        "RestoreQuantity": {
            "Type": "Task",
            "Resource": lambda_arns['restoreQuantity'],
            "ResultPath": "$.quantityRestoreStatus",
            "Next": "RestoreRedeemPoints"
        },
        "RefundCustomer": {
            "Type": "Pass",
            "Result": "Customer is refunded",
            "ResultPath": "$.refundStatus",
            "Next": "RestoreQuantity"
        },
        "BookNotFoundError": {
            "Type": "Pass",
            "Result": "No such book available",
            "End": True
        },
        "BookOutOfStockError": {
            "Type": "Pass",
            "Result": "Sorry, the book is out of stock",
            "End": True
        },
        "RedeemPointsError": {
            "Type": "Pass",
            "Result": "Error in redeeming points",
            "End": True
        },
        "BillingError": {
            "Type": "Pass",
            "Result": "Billing error",
            "ResultPath": "$.billingStatus",
            "Next": "RestoreRedeemPoints"
        }
    }
}

state_machine_arn = stepfunctions_client.create_state_machine(
    name="storeCheckoutFlow",
    definition=json.dumps(state_machine_definition),
    roleArn=stepfunctions_role_arn
)['stateMachineArn']

print("Step Functions State Machine ARN:", state_machine_arn)


# create_dynamodbs()